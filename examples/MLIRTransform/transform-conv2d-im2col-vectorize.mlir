func.func @conv_2d_nhwc_hwcf(%arg0: tensor<1x58x58x64xf32>, %arg1: tensor<3x3x64x64xf32>, %arg2: tensor<1x56x56x64xf32>) -> tensor<1x56x56x64xf32> {
    %0 = linalg.conv_2d_nhwc_hwcf
      {dilations = dense<1> : tensor<2xi64>, strides = dense<1> : tensor<2xi64> }
       ins(%arg0, %arg1: tensor<1x58x58x64xf32>, tensor<3x3x64x64xf32>)
      outs(%arg2: tensor<1x56x56x64xf32>) -> tensor<1x56x56x64xf32>
    return %0 : tensor<1x56x56x64xf32>
}

transform.sequence failures(propagate) {
  ^bb0(%arg1: !pdl.operation):

    // Use im2col method to split conv2d operation into two parts, namely "im2col" and "GEMM".
    %0 = transform.structured.match ops{["linalg.conv_2d_nhwc_hwcf"]} in %arg1 : (!pdl.operation) -> !pdl.operation
    %1:2 = transform.structured.convert_conv2d_to_img2col %0 : (!pdl.operation) -> (!pdl.operation, !pdl.operation)

    // Deal with `tensor.empty` generated by im2col method.
    %e1 = transform.structured.match ops{["tensor.empty"]} in %arg1 : (!pdl.operation) -> !pdl.operation
    %e2 = transform.cast %e1 : !pdl.operation to !transform.op<"tensor.empty">
    transform.bufferization.empty_tensor_to_alloc_tensor %e2 : (!transform.op<"tensor.empty">) -> !transform.op<"bufferization.alloc_tensor">
    
    // Tile the "im2col" part with specific parameters, while the "GEMM" part is left alone since it involves reduction and won't be transformed.
    %2 = transform.structured.match ops{["linalg.generic"]} in %1 : (!pdl.operation) -> !pdl.operation
    %3, %loops:3 = transform.structured.tile %2 [1, 64, 4] {interchange = [0, 1, 2]} : (!pdl.operation) -> (!pdl.operation, !pdl.operation, !pdl.operation, !pdl.operation)
    
    // Vectorize the "GEMM" part and turn `linalg.generic` into `vector.contract`.
    %v = get_closest_isolated_parent %3 : (!pdl.operation) -> !pdl.operation
    transform.structured.vectorize %v

    // Do bufferization.
    %b = transform.bufferization.one_shot_bufferize layout{IdentityLayoutMap}
    %arg1 {bufferize_function_boundaries = true}
    : (!pdl.operation) -> !pdl.operation
  
    // Get fine-grained operations of vector dialect.
    %f = transform.structured.match ops{["func.func"]} in %b
      : (!pdl.operation) -> !pdl.operation
    %func = transform.vector.lower_contraction %f
      lowering_strategy = "outerproduct" 
        : (!pdl.operation) -> !pdl.operation
    %func_1 = transform.vector.transfer_to_scf %func
      max_transfer_rank = 1 full_unroll = false
        : (!pdl.operation) -> !pdl.operation
}
